Project Summary: Advanced Stealth Web Automation System for High-Value Targets on Native Debian

1. Project Objective & Core Challenge:

This project aims to design and implement a robust Python-based system for performing automated text input and output tasks on major websites (e.g., eBay, Amazon, Google). The core challenge is to operate reliably and evade detection by sophisticated anti-bot systems such as Cloudflare, DataDome, and Akamai, which employ a wide array of fingerprinting and behavioral analysis techniques. The system is designed to run on a native Debian 12 (Bookworm) environment, eschewing virtual machines to minimize VM-specific detection vectors.

2. Foundational Strategy: The Three Pillars of Stealth:

The success of this system hinges on three critical pillars:

    Hardened Browser Layer: Utilizing undetected-chromedriver (UC) to eliminate common WebDriver and Chrome DevTools Protocol (CDP) fingerprints. This involves using a patched ChromeDriver that avoids typical automation flags and CDP handshakes.

    Authentic Behavioral Emulation: Implementing a "human behavior engine" that paces every click, scroll, and keystroke to mimic natural user interaction patterns, thus bypassing behavioral heuristics.

    Continuous Vigilance & Adaptation: Incorporating self-audit modules to monitor Web & TLSthrough regular updates and community monitoring.



system includes ability to use simply forwarding proxy, but for now we just use direct connections from the normal local machine, running the visual chrome instance, so we can see everything going on in the browser, as if it were a completely normal browser session with visual output, and allows the user to interact normally using mouse and keybaord, in addition to the automatic browser DOM search, interact, manipulation functionaliy.



'undetected-chromedriver sidesteps that layer, removes navigator.webdriver, randomises fingerprints, and never opens a DevTools port, so it often evades those newer checks.'

 that will allow full browser control, as well as simulating user inputs in a natural way such as clicks and random time between each keystroke when typing or editing text fields.

also priority is that we need to copy&past certain parts of the website and search the dom tree in a intelligent and efficient smart flexible and highly dynamic way adaptive to each website visited






Outcome:

This meticulously designed system, leveraging a specifically versioned and tested stack, aims to provide a high degree of resilience against common and advanced bot detection measures. This enables reliable automated interaction with high-value web targets for research and data gathering purposes, without leaking obvious CDP artifacts or WebDriver fingerprints.









system represents the pinnacle of stealth web automation - combining the robustness of enterprise software architecture with the sophistication needed to evade modern detection systems. The modular design allows for easy extension and customization while maintaining the highest levels of operational security.










The codebase follows a modular, layered architecture designed for stealth web automation:
Core Layers:
Configuration Layer: Centralized settings management
Browser Layer: Undetected-chromedriver with stealth patches

Behavior Layer: Human-like interaction patterns

DOM Layer: Intelligent element finding and content extraction
Workflow Layer:
Base Framework: Abstract workflow infrastructure
Text I/O: Generic text input/output automation
Site-Specific: Optimized modules for major websites

Key Strengths:
Stealth Focus: Undetected-chromedriver integration with advanced evasion
Human Behavior: Realistic timing, mouse movements, and interaction patterns
Adaptive DOM: Multiple fallback strategies for element location
Modular Design: Easy extension for new sites and workflows
Security Conscious: Sensitive data filtering and secure logging
The system represents a sophisticated approach to web automation that prioritizes stealth and reliability while maintaining clean, extensible architecture.










ğŸ”§ Core Architecture Components
1. Multi-Layered Configuration System
SystemConfig: Centralized configuration with security and performance parameters
Dynamic stealth parameters (WebGL vendor/renderer, timing patterns, etc.)
Fault-tolerance settings with retry logic
2. Advanced Stealth Browser Management
StealthBrowserManager: Full undetected-chromedriver integration
Advanced JavaScript patches (navigator.webdriver nullification, WebGL spoofing)
Dynamic fingerprint randomization (viewport, user-agent, language settings)
Session persistence with profile management
3. Human Behavior Emulation Engine
HumanBehaviorEngine: Sophisticated behavioral patterns
Gaussian-distributed timing with character-specific delays
Natural mouse movements with PyAutoGUI easing curves
Adaptive typing speeds and thinking pauses
4. Intelligent DOM Interaction System
AdaptiveDOMInteractor: Multi-strategy element location
CSS/XPath selectors â†’ Intelligent text matching â†’ BeautifulSoup fallback
Element caching with stale reference handling
Structured content extraction (text, forms, links, headings)
5. Orchestration & Workflow Management
WebAutomationOrchestrator: Main coordination system
Fault-tolerant workflows with exponential backoff
Adaptive waiting strategies based on page changes
Multiple submit strategies (form buttons, global search, Enter key)
ğŸ›¡ï¸ Advanced Stealth Features
âœ… Undetected-chromedriver 3.5.5 integration
âœ… Navigator.webdriver property nullification
âœ… WebGL fingerprint spoofing (Intel UHD Graphics)
âœ… Dynamic viewport randomization
âœ… User-agent rotation with fake-useragent
âœ… Language/locale coherence
âœ… Chrome DevTools Protocol avoidance
âœ… Permissions API patching
âœ… Plugin enumeration spoofing
ğŸ§  Intelligent Adaptation Features
Multi-strategy element location with semantic understanding
Human-like interaction patterns with realistic timing variations
Adaptive content extraction supporting multiple output formats
Fault-tolerant navigation with retry logic and exponential backoff
Session management with automatic cleanup and profile persistence









we use debian linux native (no VM) 

all the steps required and outline software project design in python to successfully run a kind of website text input/output system, that will work even with major sites 

(like google search, chatgpt, ebay or amazon) using cloudfare or other automation detection systems




making sure things like this are taken care of:

How undetected-chromedriver nulls those signals

        UC Patch Set
        A custom ChromeDriver binary that strips --enable-automation, never opens a DevTools port, and rewrites high-risk JS properties on every navigation.
        ZenRows

    No CDP handshake â€“ Selenium speaks the W3C WebDriver wire protocol; UC's driver therefore avoids Runtime.enable and the whole DevTools event family.
    DataDome

    navigator.webdriver removed and $cdc_â€¦ script ghosted at document-start, so the canonical Selenium probes fail.
    ZenRows

    Permissions & Client-Hints patched â€“ navigator.permissions.query gets stubbed, and Sec-CH-UA* headers rotate to plausible combinations.
    ZenRows

    Profile-wide hooks â€“ every new tab, iframe or service-worker receives the same stealth JS without you writing extra injection logic.
    ZenRows




Login/Authentication: The current workflow assumes direct access to the chat interface. If login is required, this would be a significant additional feature, potentially involving secure credential management and a more complex initial navigation sequence.


Multi-turn Conversations: The current workflow handles a single prompt and response. For multi-turn conversations, the workflow would need to be extended to manage conversation history, potentially identify the correct input field for follow-up prompts, and append new responses.
Error Handling & Robustness: Interacting with complex web applications can lead to many edge cases. Further enhancing error handling within the workflow (e.g., for when elements are not found even after waiting, or when the page structure changes unexpectedly) would be beneficial.







When the script reaches an intervention point, it will print a message in the console and pause.
You can then switch to the visible Chromium browser window and interact with the page as needed (e.g., inspect elements, manually click something the bot missed, solve a CAPTCHA if it appears, copy some text, etc.).
Once you are done with your manual interaction, return to the console where the script is paused and press Enter.
The automation will resume from where it left off.
This feature adds a powerful debugging and recovery mechanism, allowing you to "step in" when the automation might be struggling or when you want to explore the page state at a specific point in the workflow. Since the browser is already running in non-headless mode, this integration is primarily about pausing the script execution gracefully.













3. Bill of Materials & Versioning (Tested on Debian 12, Python 3.11, as of May 18, 2025):

Strict version pinning is crucial for reproducibility and maintaining the integrity of stealth patches, especially the link between undetected-chromedriver, the specific ChromeDriver binary it patches, and the Chromium browser version.

    Base Runtime (APT Packages - Debian 12 "Bookworm"):

        chromium: 136.0.7103.113-1~deb12u1 (GUI browser for profile sharing/aging)

        chromium-driver: 136.0.7103.113 (Managed by UC to match Chromium M136)

        xclip, xsel, scrot, libxtst6, x11-utils: Standard Bookworm versions (for PyAutoGUI & pyperclip X11 interactions)

    Core Python Libraries (Python 3.11.2 environment):

        Stealth Driver:

            undetected-chromedriver==3.5.5 (Latest PyPI; compatible with Selenium â‰¥ 4.9)

            selenium==4.32.0 (Current stable; endorsed by UC 3.5.5)

        Browser Fingerprint Management:

            fake-useragent==2.2.0 (For User-Agent rotation)

        Human Behavior Engine:

            PyAutoGUI==0.9.54 (Cross-platform mouse/keyboard control)

            pillow==11.2.1 (Dependency for PyAutoGUI)

            python-xlib==0.33 (Dependency for PyAutoGUI on Linux)

        Clipboard Operations:

            pyperclip==1.9.0 (Cross-platform copy/paste)

        DOM Parsing & Data Extraction:

            beautifulsoup4==4.13.4 (Production-grade HTML parser)

            lxml==5.4.0 (Fast XML/HTML parser, linked against libxml2 2.13.8)

        Network & TLS Self-Tests:

            httpx[http2]==0.28.1 (HTTP/1.1 + HTTP/2 client)

            cryptography==45.0.1 (For potential cryptographic needs in TLS checks)











4. Key Evasion Techniques & Implementation Details:

    Nullifying WebDriver & CDP Artifacts (via undetected-chromedriver 3.5.5):

        Automatic removal of --enable-automation and other incriminating flags.

        Avoidance of user-discoverable DevTools ports and Runtime.enable CDP handshakes.

        Ensuring navigator.webdriver is undefined and $cdc_... scripts are ghosted.

        Patching navigator.permissions.query to return more plausible states.

        Rotation of Sec-CH-UA-* (Client Hints) headers.

        Profile-wide application of stealth JavaScript to all contexts (tabs, iframes).

    Addressing Residual JavaScript Fingerprints (Manual/Scripted Enhancements):

        WebGL Vendor/Renderer: Utilizing a stealth() helper function (e.g., uc_stealth.stealth()) with driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", ...) to inject scripts that modify WebGL parameters (e.g., webgl_vendor="Intel Inc.", renderer="Mesa Intel UHD") to match the host or a common configuration.

        navigator.plugins & mimeTypes: Injecting scripts at document_start to populate these with realistic data copied or modeled from a genuine user profile, avoiding empty arrays.

        Permissions API: While UC provides basic stubbing, site-specific probes for unusual permission scopes can be handled by custom preload scripts that modify navigator.permissions.query behavior further.

    Network-Level Stealth (network_guard.py):

        IP Reputation: Employing high-quality residential or ISP proxy pools, with rotation strategies.

        TLS Fingerprint (JA3/JA4) Integrity: Prioritizing Chromium's native TLS stack. Avoiding Python-based proxy solutions (like requests proxies) that might terminate and re-initiate TLS with a detectable OpenSSL fingerprint. Self-testing JA3 hash against known good values using external echo services via httpx.

        HTTP/2 Consistency: Ensuring proxies do not downgrade HTTP/2, as this can be a WAF signal.

    Behavioral Mimicry (human_input.py):

        Mouse Movements: Leveraging PyAutoGUI for OS-level mouse control, implementing easing curves (e.g., easeInOutQuad) and random pixel jitter (Â±4px) for natural paths.

        Keystroke Dynamics: Introducing variable delays (e.g., 80-250ms with Gaussian noise) between individual character inputs.

        Scrolling: Simulating human-like scrolling patterns (e.g., window.scrollBy in smaller, paced bursts rather than instant jumps).

        Pacing & Idle Time: Incorporating random "thinking time," tab switches, and pauses to avoid overly efficient or robotic interaction patterns (e.g., average interaction times >20ms).

    Smart DOM Interaction (dom_adapter.py):

        Implementing a smart_find function that attempts robust Selenium locators first, then falls back to BeautifulSoup4 with lxml for flexible text or regex-based searching on driver.page_source when dynamic IDs/classes break standard selectors.

    Locale Coherence:

        Strict synchronization of OS timezone, browser's Intl.DateTimeFormat().resolvedOptions().timeZone, navigator.languages, HTTP Accept-Language headers, and the geolocation of the proxy's exit IP.



5. Software Architecture & Operational Management:




Project Structure

```
src/
â”œâ”€â”€ core/                     # Core framework components
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ config.py            # Centralized configuration
â”‚   â”œâ”€â”€ stealth_browser.py   # Browser management
â”‚   â”œâ”€â”€ human_behavior.py    # Human emulation
â”‚   â””â”€â”€ dom_interactor.py    # DOM interaction
â”œâ”€â”€ workflows/               # Workflow framework
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base_workflow.py     # Abstract workflow base
â”‚   â””â”€â”€ text_io_workflow.py  # Text I/O workflow
â”œâ”€â”€ sites/                   # Site-specific modules â­
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base_site.py         # Site module framework
â”‚   â”œâ”€â”€ google.py            # Google automation
â”‚   â”œâ”€â”€ amazon.py            # Amazon automation
â”‚   â””â”€â”€ ebay.py              # eBay automation
â”œâ”€â”€ security/                # Optional security features
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ basic_stealth.py     # Essential stealth only
â”œâ”€â”€ utils/                   # Utilities
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ logger.py            # Logging system
â”œâ”€â”€ main.py                  # Simplified entry point
â””â”€â”€ test_system.py           # System verification
```





The system is structured as a modular Python project:

    bootstrap.py: Environment checks, UC auto-updates.

    session_manager.py: Manages cloned real browser profiles, UA/viewport settings, JA3 self-tests, proxy selection.

    stealth_browser.py: Wrapper for undetected-chromedriver launch and initial patching.

    human_input.py: Behavioral engine using PyAutoGUI.

    dom_adapter.py: Advanced DOM interaction and data extraction.

    network_guard.py: TLS monitoring, proxy/vpn support layer

    monitoring.py: Fingerprint self-check dashboards (e.g., against bot.sannysoft.com).

    task_runner.py: Orchestrates site-specific workflows.

Operational procedures include:

    Cloning and periodically "aging" real Chrome user profiles through manual browsing.
















6. Deliverables & Implementation:

A key deliverable is a precisely versioned requirements.txt file (as provided in the bill of materials) to ensure reproducible environments. A quick install cheat-sheet and a post-install script to verify Chromium-ChromeDriver version alignment facilitate setup.

requirements.txt (summary):

      
undetected-chromedriver==3.5.5
selenium==4.32.0
PyAutoGUI==0.9.54
pillow==11.2.1
python-xlib==0.33
pyperclip==1.9.0
fake-useragent==2.2.0
beautifulsoup4==4.13.4
lxml==5.4.0
httpx[http2]==0.28.1
cryptography==45.0.1

    






1â€‚Why these versions were selected
Chromium 136.0.7103.113 is the current security-patched build in Debian 12 ("bookworm") and ships with a matching chromium-driver; keeping browser and driver in the same milestone avoids crashes and patch mismatch. 
Debian Packages

undetected-chromedriver 3.5.5 patches that exact driver, strips --enable-automation, keeps navigator.webdriver undefined, and dodges CDP handshakes. 
PyPI

Selenium 4.32.0 is the newest W3C-compliant client; UC 3.5.5 explicitly supports Selenium â‰¥ 4.9 and has been tested up to 4.32. 
Selenium
PyPI

Every listed Python library is pinned to the latest release compatible with Python 3.11 and each other (PyPI dates between Feb 2024 â€“ May 2025).
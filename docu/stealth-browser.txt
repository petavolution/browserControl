Stealth isn’t a single trick—it’s a multi-layered disguise. You must eliminate protocol fingerprints, spoof every JS surface, match genuine transport-layer behaviours, emulate human interactions, anchor in a real user profile, and continuously self-audit. Only then will your undetected-chromedriver-driven, fully visible Chrome session surf and interact like a genuine human visitor, evading today’s most sophisticated anti-bot defenses.


using undetected_chromedriver
we want to consider and implement ALL possible things we need to consider to have a perfectly stealth remote controlled but realy visible browser sucessfull surfing and interacting with websites, without being detected as automation !!


such as:




1 Automation-Protocol Artefacts
1.1 WebDriver Flags & Globals
navigator.webdriver removal: UC patches ChromeDriver so navigator.webdriver is always undefined, thwarting the simplest Selenium probes .

Ghosting “cdc_…” script: The injected __webdriver_script_fn markers (e.g. cdc_XXXX) are stripped on every navigation .

1.2 Chrome DevTools Protocol (CDP) Side-Effects
No CDP handshake: UC uses the WebDriver wire protocol instead of CDP’s Runtime.enable, so anti-bot scripts cannot detect DevTools domains being activated .

DevToolsActivePort file & TCP-port hiding: UC avoids launching with --remote-debugging-port, eliminating on-disk “DevToolsActivePort” markers and open ports that fraud-prevention systems scan .

2 JavaScript-Level Fingerprinting
2.1 Core Fingerprint Surfaces
User-Agent & Client Hints: Rotate User-Agent and Sec-CH-UA* headers via UC’s built-in helpers or fake-useragent, ensuring they match a real Chrome 136 profile .

navigator.plugins & mimeTypes: Populate from your cloned real profile or inject dummy objects at document_start to avoid empty arrays .

canvas fingerprint: Randomise canvas-hash jitter by varying viewport size or injecting slight noise via a preload script .

AudioContext fingerprint: Inject sample-noise overrides so audio-fingerprint hashes don’t match headless/OpenSSL defaults .

2.2 Graphics & Hardware Attributes
WebGL vendor/renderer: Spoof UNMASKED_VENDOR_WEBGL and UNMASKED_RENDERER_WEBGL to “Intel Inc. / Mesa Intel® UHD Graphics” or your actual GPU .

Screen resolution & colorDepth: Match OS settings, and randomise within human-plausible ranges (e.g. 1280×720 → 1600×900) each session .

hardwareConcurrency & deviceMemory: Override via Page.addScriptToEvaluateOnNewDocument so CPU cores and RAM values align with your VM/host .

2.3 Additional API Signals
Permissions API: Stub navigator.permissions.query to return realistic states (granted for notifications, etc.) .

Touch & Pointer Events: Expose ontouchstart and pointer event counts to simulate mobile or touch-capable devices .

WebRTC & IP leak: Disable or carefully stub RTCPeerConnection to avoid leaking local IPs or raising WebRTC probes .

CSS media queries & installed fonts: Mirror your real font list and response to @media queries (e.g. color-gamut, prefers-color-scheme) .

3 Environment & Profile Consistency
Clone real user-data directory: Use your daily ~/.config/chromium to inherit cookies, history, extensions, TLS sessions, and genuine navigator.plugins .

Fonts & locale coherence: Ensure system fonts match those reported by JS enumeration and that OS timezone, navigator.language(s), and Accept-Language align with your proxy exit IP .

Service Workers & localStorage: Keep a living profile with aged ServiceWorkers and localStorage entries to avoid “new profile” flags .


5 Behavioral Emulation
Mouse movement: Use PyAutoGUI with easing curves (e.g. easeInOutQuad) and ±3 px jitter over 0.3–0.7 s paths .

Keystroke dynamics: Introduce per-character delays (80–250 ms with Gaussian noise) and occasional backspaces to mimic real typing .

Scrolling patterns: Paginate via window.scrollBy(…) in 150–300 px bursts with varied pauses (0.1–0.3 s) rather than instant jumps .

Idle & focus shifts: Randomly switch tabs, blur/focus windows, and insert 5–15 s “reading breaks” after major interactions .


